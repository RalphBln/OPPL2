/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. oppl.jj */
/*@egen*//**
* JJTree file
*/

options {
	             
  JDK_VERSION = "1.5";
                
                       
STATIC = false;
   /* DEBUG_PARSER=true; */

}

PARSER_BEGIN(OPPLParser)
package org.coode.oppl.syntax;
import java.io.Reader;
import java.net.URI;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.Arrays;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

import org.coode.manchesterowlsyntax.ManchesterOWLSyntaxEditorParser;
import org.coode.oppl.AbstractConstraint;
import org.coode.oppl.InCollectionConstraint;
import org.coode.oppl.InCollectionRegExpConstraint;
import org.coode.oppl.InequalityConstraint;
import org.coode.oppl.OPPLAbstractFactory;
import org.coode.oppl.OPPLFactory;
import org.coode.oppl.OPPLQuery;
import org.coode.oppl.OPPLScript;
import org.coode.oppl.exceptions.OPPLException;
import org.coode.oppl.validation.OPPLScriptValidator;
import org.coode.oppl.variablemansyntax.ConstraintSystem;
import org.coode.oppl.variablemansyntax.ExpressionParser;
import org.coode.oppl.variablemansyntax.Variable;
import org.coode.oppl.variablemansyntax.VariableManchesterOWLSyntaxParser;
import org.coode.oppl.variablemansyntax.VariableScope;
import org.coode.oppl.variablemansyntax.VariableScopes;
import org.coode.oppl.variablemansyntax.VariableType;
import org.coode.oppl.variablemansyntax.VariableScopes.Direction;
import org.coode.oppl.variablemansyntax.generated.Attribute;
import org.coode.oppl.variablemansyntax.generated.AbstractCollectionGeneratedValue;
import org.coode.oppl.variablemansyntax.generated.ConcatGeneratedValues;
import org.coode.oppl.variablemansyntax.generated.RegExpGenerated;
import org.coode.oppl.variablemansyntax.generated.VariableIndexGeneratedValue;
import org.coode.oppl.variablemansyntax.generated.StringGeneratedValue;
import org.coode.oppl.variablemansyntax.generated.SingleValueGeneratedValue;
import org.coode.oppl.variablemansyntax.generated.SingleValueGeneratedVariable;
import org.coode.oppl.variablemansyntax.generated.factory.AttributeFactory;
import org.semanticweb.owl.apibinding.OWLManager;
import org.semanticweb.owl.expression.ParserException;
import org.semanticweb.owl.inference.OWLReasoner;
import org.semanticweb.owl.model.AddAxiom;
import org.semanticweb.owl.model.OWLAxiom;
import org.semanticweb.owl.model.OWLAxiomChange;
import org.semanticweb.owl.model.OWLClass;
import org.semanticweb.owl.model.OWLDataProperty;
import org.semanticweb.owl.model.OWLDescription;
import org.semanticweb.owl.model.OWLObject;
import org.semanticweb.owl.model.OWLObjectProperty;
import org.semanticweb.owl.model.OWLOntology;
import org.semanticweb.owl.model.OWLOntologyManager;
import org.semanticweb.owl.model.RemoveAxiom;
import org.semanticweb.owl.model.OWLEntity;

public class OPPLParser/*@bgen(jjtree)*/implements OPPLParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTOPPLParserState jjtree = new JJTOPPLParserState();

/*@egen*/
	private OWLOntologyManager owlOntologyManager;

	private OPPLAbstractFactory opplFactory = null;
	private List completions = new ArrayList();

	private OWLOntology ontology;
	private OWLReasoner reasoner;
	private OPPLScriptValidator validator=null;

	public void setOPPLScriptValidator(OPPLScriptValidator v){
		validator = v;
	}

	public List getCompletions(){
		return completions;
	}

	public OPPLAbstractFactory getOPPLFactory(){
		if(opplFactory ==null){
			opplFactory = new OPPLFactory(owlOntologyManager, ontology, reasoner);
		}
		return opplFactory;
	}

	public void setOPPLFactory(OPPLAbstractFactory factory){
		opplFactory = factory;
	}

	public OWLOntologyManager getOWLOntologyManager(){
		return owlOntologyManager;
	}

	public void setReasoner(OWLReasoner r){
		reasoner = r;
	}

   public OPPLParser(java.io.InputStream in, OWLOntologyManager m, OWLOntology o, OWLReasoner r){
		this(in);
   		owlOntologyManager = m;
   		ontology = o;
   		reasoner = r;
   }

   	public void ReInit(Reader reader,
			OWLOntologyManager m, OWLOntology o, OWLReasoner r){
		ReInit(reader);
		owlOntologyManager = m;
		ontology = o;
   		reasoner = r;
	}

   	public OPPLParser(Reader reader, OWLOntologyManager m,
			OWLOntology o, OWLReasoner r) {
		this(reader);
		owlOntologyManager = m;
		ontology = o;
   		reasoner = r;
	}

	public static void main(String args[]) {
    	System.out.println("Reading from standard input...");
    	System.out.print("Enter an expression :");
    	String ontologyPhysicalURI = args[0];
		OWLOntologyManager m = OWLManager.createOWLOntologyManager();
    try {
	  OWLOntology o = m.loadOntology(URI.create(ontologyPhysicalURI));

      OPPLScript n = new OPPLParser(System.in, m, o, null).Start();
      System.out.println("Thank you.");
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
private ParseException unexpectedException() {
	return new ParseException("Unexpected condition at line " + this.token.beginLine + " column " + this.token.beginColumn + ": " + this.token.image);
}

}
PARSER_END(OPPLParser)

SKIP :
{" "| "\t"| "\n"| "\r"| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>| <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">}
TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL: <DECIMAL_LITERAL> (["l","L"])? | <HEX_LITERAL> (["l","L"])? | <OCTAL_LITERAL> (["l","L"])?>
|  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
}
TOKEN:/*metachars*/
{<REGEXPMETACHAR:["\\","-","$","|","?","*"]>}
TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: "?" <NAME> >
| <#NAME:  <LETTER> (<LETTER>|<DIGIT>)*>
|  < #LETTER: ["_","\'","a"-"z","A"-"Z", "\u00e0"-"\u00f9"] >
|  < #DIGIT: ["0"-"9"] >
}

TOKEN[IGNORE_CASE]:/* OPPL FUNCTIONS*/
{	<CREATE:   "create">
	| <CREATEINTERSECTION: "CreateIntersection">
	| <CREATEUNION: "CreateUnion">
	| <MATCH:"Match">
}

TOKEN :/* VARIABLE TYPES*/
{<VARIABLETYPE: "CLASS" | "OBJECTPROPERTY" | "DATAPROPERTY" | "INDIVIDUAL" | "CONSTANT">}


TOKEN[IGNORE_CASE]: /* OPPL SYNTAX*/
{<SELECT: "SELECT"> |<WHERE: "WHERE">| <ASSERTED: "ASSERTED"> | <ADD: "ADD"> | <REMOVE: "REMOVE"> |<BEGIN: "BEGIN"> |<END: "END">}

TOKEN: /*PUNCTUATION*/
{<COMMA:",">
	| <SEMICOLON: ";">
	| <APO: "'">
	| <COLON: ":">
	| <OPENPARENTHESYS: "(">
	| <CLOSEDPARENTHESYS: ")">
	| <QUOTE: "\"">
	| <POWER: "^">
	| <OPENCURLYBRACKETS: "{">
	| <CLOSEDCURLYBRACKETS: "}">
	| <OPENSQUAREBRACKETS: "[">
	| <CLOSEDSQUAREBRACKETS: "]">
}

TOKEN[IGNORE_CASE]: /* CONSTRAINT SYNTAX*/
{ <NEQ: "!="> | <IN: "IN"> }

TOKEN: /* CREATED ENTITIES */
{	<GENERATEDENTITY: "!"<ENTITYNAMES>> }

TOKEN: /* MANSYNTAX KEYWORDS */
{	<SUBCLASSOF: "SubClassOf" | "subClassOf">
	|<EQUIVALENTTO: "EquivalentTo" | "equivalentTo">
	|<DISJOINTWITH: "DisjointWith" | "disjointWith">
	|<DISJOINT_UNION_OF: "DisjointUnionOf">
	|<FUNCTIONAL: "Functional">
	|<INVERSE: "inv">
	|<INVERSE_FUNCTIONAL: "InverseFunctional">
	|<SUB_PROPERTY_OF: "SubPropertyOf" | "subPropertyOf">
	|<SYMMETRIC: "Symmetric">
	|<TRANSITIVE: "Transitive">
}

TOKEN : /* VARIABLE SCOPE OTHER DIRECTIONS */
{	<OTHERDIRECTION: <SUPERCLASSOF> |<SUPER_PROPERTY_OF> |<INSTANCE_OF>>
	| <#SUPERCLASSOF: "SuperClassOf"|"superClassOf">
	|<#SUPER_PROPERTY_OF: "SuperPropertyOf"|"superPropertyOf">
	|<#INSTANCE_OF: "InstanceOf"|"instanceOf">
}



TOKEN :/* VARIABLE ATTRIBUTES*/
{	<RENDERINGVARIABLEATTRIBUTE: "RENDERING">|<VALUESVARIABLEATTRIBUTE: "VALUES">|<GROUPSVARIABLEATTRIBUTE: "GROUPS">}

TOKEN : /* MANSYNTAX ENTITY NAMES */
{	<ENTITYNAMES : <LETTER> (<LETTER>|<DIGIT>)*>}

TOKEN: /* LITERALS*/
{	<LITERAL: <QUOTE><ENTITYNAMES><QUOTE><POWER><POWER><ENTITYNAMES>(<COLON> <ENTITYNAMES>)?>}

OPPLScript Start():{/*@bgen(jjtree) Start */
  SimpleNode jjtn000 = new SimpleNode(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
try {
/*@egen*//*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{return parse(null);}/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

OPPLScript parse(ConstraintSystem cs):{/*@bgen(jjtree) parse */
        SimpleNode jjtn000 = new SimpleNode(JJTPARSE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	List<Variable> variables = new ArrayList<Variable>();
	OPPLQuery opplQuery = null;
	List<OWLAxiomChange> actions = new ArrayList<OWLAxiomChange>();
	ConstraintSystem constraintSystem = cs;
	if(constraintSystem==null){constraintSystem = getOPPLFactory().createConstraintSystem();}
}
{/*@bgen(jjtree) parse */
  try {
/*@egen*/
  (variables = VariableDeclaration(constraintSystem))?(opplQuery = query(constraintSystem))?(actions = Actions(constraintSystem))?";"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
  	OPPLScript toReturn = getOPPLFactory().buildOPPLScript(constraintSystem, variables, opplQuery, actions);
  	if(validator !=null && !validator.accept(toReturn)){
  		throw new ParseException("Failed validation "+validator.getValidationRuleDescription());
  	}
  	return toReturn;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

List<Variable> VariableDeclaration(ConstraintSystem constraintSystem)       :
{List<Variable> toReturn = new ArrayList<Variable>();
Variable v;}
{
	v =VariableDefinition(constraintSystem)
		{	toReturn.add(v);
			completions.clear();
			completions.add(",");
			completions.add("SELECT");
		}
	(	<COMMA>{completions.clear();}
		v = VariableDefinition(constraintSystem)
			{	toReturn.add(v);
				completions.clear();
				completions.add(",");
				completions.add("SELECT");
			}
	)*
	{return toReturn;}
}

List<OWLAxiomChange> Actions(ConstraintSystem constraintSystem):{/*@bgen(jjtree) Actions */
                                                                 SimpleNode jjtn000 = new SimpleNode(JJTACTIONS);
                                                                 boolean jjtc000 = true;
                                                                 jjtree.openNodeScope(jjtn000);
/*@egen*/List<OWLAxiomChange> toReturn = new ArrayList<OWLAxiomChange>(); OWLAxiomChange action;}
{/*@bgen(jjtree) Actions */
        try {
/*@egen*/
	<BEGIN> 	action = Action(constraintSystem){toReturn.add(action);}
	(	<COMMA> action = Action(constraintSystem){toReturn.add(action);}
	)*<END>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{return toReturn;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

Variable VariableDefinition(ConstraintSystem constraintSystem):
	{/*@bgen(jjtree) VariableDefinition */
                SimpleNode jjtn000 = new SimpleNode(JJTVARIABLEDEFINITION);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/	Token variableNameToken;
		Token variableTypeToken;
		VariableType variableType=null;
		VariableScope variableScope;
		Token directionToken=null;
		VariableScopes.Direction direction=null;
		Variable v=null;
	}
	{/*@bgen(jjtree) VariableDefinition */
        try {
/*@egen*/
	LOOKAHEAD(4)
	variableNameToken= <IDENTIFIER> <COLON>
		{	completions.clear();
			completions.addAll(EnumSet.allOf(VariableType.class));
		}
	variableTypeToken= <VARIABLETYPE>
		{variableType = VariableType.valueOfIgnoreCase(variableTypeToken.image);}
	"=" v = opplFunction(variableNameToken.image,variableType,constraintSystem)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{return v;}
	|LOOKAHEAD(4)
	variableNameToken= <IDENTIFIER> <COLON>
		{	completions.clear();
			completions.addAll(EnumSet.allOf(VariableType.class));
		}
	variableTypeToken= <VARIABLETYPE>
		{
			try{
				variableType = VariableType.valueOfIgnoreCase(variableTypeToken.image);
    	        v =  constraintSystem.createVariable(variableNameToken.image,variableType);
			}catch(OPPLException e){throw new ParseException(e.getMessage(), e);}
		}
	<OPENSQUAREBRACKETS>
		{
			completions.clear();
			completions.addAll(EnumSet.allOf(VariableScopes.Direction.class));
		}
	direction = direction()
	variableScope = typeScope(direction, variableType,constraintSystem)
	<CLOSEDSQUAREBRACKETS>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{
			v.setVariableScope(variableScope, getOPPLFactory().getVariableScopeChecker());
			return v;
		}
	|variableNameToken= <IDENTIFIER> <COLON>
		{
			completions.clear();
			completions.addAll(EnumSet.allOf(VariableType.class));
		}
	variableTypeToken = <VARIABLETYPE>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{
			completions.clear();
			try{
				variableType = VariableType.valueOfIgnoreCase(variableTypeToken.image);
				return constraintSystem.createVariable(variableNameToken.image,variableType);
			}catch(OPPLException e){throw new ParseException(e.getMessage(), e);}
		}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


Variable opplFunction(String name,VariableType type, ConstraintSystem constraintSystem)      :
{	SingleValueGeneratedValue<String> value=null;
	AbstractCollectionGeneratedValue<? extends OWLObject> collection=null;
	SingleValueGeneratedVariable expressionVariable;
	SingleValueGeneratedValue<String> expression;
	Variable regexpVariable;
}
{
	<MATCH><OPENPARENTHESYS>expression=stringOperation(constraintSystem, true)<CLOSEDPARENTHESYS>
		{
		regexpVariable = regexpOperation(name, type, expression, constraintSystem);
		return regexpVariable;
		}
	|
	<CREATE><OPENPARENTHESYS>value = stringOperation(constraintSystem, true)<CLOSEDPARENTHESYS>
		{return constraintSystem.createStringGeneratedVariable(name,type, value);}
	|<CREATEINTERSECTION><OPENPARENTHESYS>collection = set(type,constraintSystem)<CLOSEDPARENTHESYS>
		{return constraintSystem.createIntersectionGeneratedVariable(name,type,(AbstractCollectionGeneratedValue<OWLClass>) collection);}
	|<CREATEUNION><OPENPARENTHESYS> collection = set(type,constraintSystem)<CLOSEDPARENTHESYS>
		{return constraintSystem.createUnionGeneratedVariable(name,type,(AbstractCollectionGeneratedValue<OWLClass>) collection);}
	| expressionVariable = expressionGeneratedVariable(name,type,constraintSystem)
		{return expressionVariable;}
}

JAVACODE
SingleValueGeneratedVariable expressionGeneratedVariable(String name,VariableType type, ConstraintSystem constraintSystem){/*@bgen(jjtree) expressionGeneratedVariable */
SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSIONGENERATEDVARIABLE);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
try {
/*@egen*/
int beginningSubSection = token.beginColumn;
int beginningSubSectionLine = token.beginLine;
String expression = Utils.readString(this, false, COMMA, SELECT);
try {
	return Utils.parseVariableExpressionGeneratedVariable(name,	type, expression, constraintSystem);
} catch (ParserException e) {
Exception temp=Utils.buildException(beginningSubSection, beginningSubSectionLine, e);
throw new ParseException(temp.getMessage(), temp);}/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

JAVACODE
Variable regexpOperation(String name,VariableType type, SingleValueGeneratedValue<String> expression, ConstraintSystem constraintSystem){/*@bgen(jjtree) regexpOperation */
SimpleNode jjtn000 = new SimpleNode(JJTREGEXPOPERATION);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
try {
/*@egen*/
int beginningSubSection = token.beginColumn;
int beginningSubSectionLine = token.beginLine;

//try {
//	Pattern.compile(expression);
//} catch (PatternSyntaxException e) {
//Exception temp=Utils.buildException(expression, beginningSubSection, beginningSubSectionLine, e);
//throw new ParseException(temp.getMessage(), temp);
//}
try {
	return Utils.parseRegexpGeneratedVariable(name,	type, expression, constraintSystem);
} catch (ParserException e) {
Exception temp=Utils.buildException(beginningSubSection, beginningSubSectionLine, e);
throw new ParseException(temp.getMessage(), temp);
}/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

AbstractCollectionGeneratedValue<? extends OWLObject> set(VariableType type,ConstraintSystem constraintSystem)      :
{Token variableNameToken=null;}
{
	variableNameToken = <IDENTIFIER>"."<VALUESVARIABLEATTRIBUTE>
		{	String variableName = variableNameToken.image;
			Variable v = constraintSystem.getVariable(variableName);
			if (v != null) {
				if (type == v.getType()) {
					Attribute attribute = Attribute.VALUES;
					return AttributeFactory.getCollectionGeneratedValue(attribute, v, constraintSystem);
				} else {throw new ParseException("Type mismatch for variable " + v.getName() + ": type " + type + " needed instead of the actual " + v.getType());}
			} else {throw new ParseException("Invalid variable name: " + variableName);}
		}
}

SingleValueGeneratedValue<String> stringOperation(ConstraintSystem constraintSystem, boolean spacesAdded)      :
{SingleValueGeneratedValue result=null;}
{
	result = stringConcat(constraintSystem, spacesAdded)
		{return result;}
}

SingleValueGeneratedValue<String> stringConcat(ConstraintSystem constraintSystem, boolean spacesAdded)      :
{	SingleValueGeneratedValue aGeneratedValue;
	List<SingleValueGeneratedValue<String>> components = new ArrayList<SingleValueGeneratedValue<String>>();
}
{
	aGeneratedValue = generatedValue(constraintSystem, spacesAdded)
		{components.add(aGeneratedValue);}
	("+"  aGeneratedValue = generatedValue(constraintSystem, spacesAdded)
		{components.add(aGeneratedValue);}
	)*
		{if(components.size()==1){return aGeneratedValue;}else{return new ConcatGeneratedValues(components);}}
}

SingleValueGeneratedValue generatedValue(ConstraintSystem constraintSystem, boolean spacesAdded)      :
{	String valueToken;
	Token variableNameToken;
	Token variableAttributeToken;
}
{
	<QUOTE>valueToken = readString(spacesAdded)<QUOTE>
		{return new StringGeneratedValue(valueToken);}
	|LOOKAHEAD(4)
	variableNameToken = <IDENTIFIER>"." variableAttributeToken = <RENDERINGVARIABLEATTRIBUTE>
		{	String attributeString = variableAttributeToken.image;
			String variableName = variableNameToken.image;
			Variable v = constraintSystem.getVariable(variableName);
			if(v !=null){
				try {
					Attribute attribute = Attribute.valueOf(attributeString);
					return AttributeFactory.getVariableGeneratedValue(attribute, v, constraintSystem);
				} catch (IllegalArgumentException e) {throw new ParseException("Invalid attribute name: " + e.getMessage() + "; valid names are: " + Arrays.toString(Attribute.values()));}
		}else{throw new ParseException("Invalid variable name: "+variableName);}
		}
	|LOOKAHEAD(4)
	variableNameToken = <IDENTIFIER>"." <GROUPSVARIABLEATTRIBUTE><OPENPARENTHESYS> variableAttributeToken = <INTEGER_LITERAL><CLOSEDPARENTHESYS>
		{
		String attributeString = variableAttributeToken.image;
		String variableName = variableNameToken.image;
		Variable v = constraintSystem.getVariable(variableName);
		if (v != null) {
			int index = Integer.parseInt(attributeString);
			RegExpGenerated gv = (RegExpGenerated) v;
			Set<OWLObject> bindings = gv.getPossibleBindings();
			if (bindings.size() > 0) {
				VariableIndexGeneratedValue toReturn=new VariableIndexGeneratedValue(gv, index, bindings);
				return toReturn;
			}
			throw new ParseException("No matches found for variable: " + v);
		}else{throw new ParseException("Invalid variable name: "+variableName);}
		}
}

JAVACODE
String readString(boolean spacesAdded){/*@bgen(jjtree) readString */
SimpleNode jjtn000 = new SimpleNode(JJTREADSTRING);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
try {
/*@egen*/
return Utils.readString(this, spacesAdded, QUOTE);/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}


VariableScopes.Direction direction()      : {Token t=null;}
{
	<SUBCLASSOF>
		{return Direction.SUBCLASSOF;}
	| <SUB_PROPERTY_OF>
		{return Direction.SUBPROPERTYOF;}
	| t = <OTHERDIRECTION>
		{return Direction.getDirection(t.image);}
}


JAVACODE
VariableScope typeScope(VariableScopes.Direction direction, VariableType variableType, ConstraintSystem constraintSystem){/*@bgen(jjtree) typeScope */
     SimpleNode jjtn000 = new SimpleNode(JJTTYPESCOPE);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);
     try {
/*@egen*/
	int beginningSubSection = -1;
	int beginningSubSectionLine = -1;
	Token t;
	StringBuilder manSyntax = new StringBuilder();
	VariableScope toReturn = null;
	while (true) {
		t = getToken(1);
		if (beginningSubSection < 0) {
			beginningSubSection = t.beginColumn;
		}
		if (beginningSubSectionLine < 0) {
			beginningSubSectionLine = t.beginLine;
		}
		if (t.kind == COMMA || t.kind == CLOSEDSQUAREBRACKETS || t.kind == SEMICOLON || t.kind == BEGIN || t.kind == END || t.kind == WHERE || t.kind == EOF) {
			break;
		} else {
			manSyntax.append(t.image);
			manSyntax.append(" ");
			t = getNextToken();
		}
	}
	String manSyntaxString = manSyntax.toString().trim();
	completions.clear();
	// VariableManchesterOWLSyntaxParser parser = new
	// VariableManchesterOWLSyntaxParser(
	// manSyntaxString, constraintSystem);
	ManchesterOWLSyntaxEditorParser parser = new ManchesterOWLSyntaxEditorParser(getOWLOntologyManager().getOWLDataFactory(), manSyntaxString);
	parser.setOWLEntityChecker(getOPPLFactory().getOWLEntityChecker());
	try {
		toReturn = parseScope(direction, variableType, parser);
	} catch (ParserException e) {
		// No need to correct the column indexes on this exception, it
		// has been done near the generation point
		throw new ParseException("Failed to parse the description " + manSyntaxString, e);
	}
	return toReturn;/*@bgen(jjtree)*/
     } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
     }
/*@egen*/
}

JAVACODE
VariableScope parseScope(VariableScopes.Direction direction,
			VariableType variableType, ManchesterOWLSyntaxEditorParser parser)
			throws ParserException {/*@bgen(jjtree) parseScope */
             SimpleNode jjtn000 = new SimpleNode(JJTPARSESCOPE);
             boolean jjtc000 = true;
             jjtree.openNodeScope(jjtn000);
             try {
/*@egen*/
		VariableScope scope = null;
		int beginningSubSection = token.beginColumn;
		int beginningSubSectionLine = token.beginLine;
		try {
			scope = variableType.parseVariable(direction, parser);
		} catch (ParserException e) {throw Utils.buildException(beginningSubSection, beginningSubSectionLine, e);}
		return scope;/*@bgen(jjtree)*/
             } catch (Throwable jjte000) {
               if (jjtc000) {
                 jjtree.clearNodeScope(jjtn000);
                 jjtc000 = false;
               } else {
                 jjtree.popNode();
               }
               if (jjte000 instanceof ParserException) {
                 throw (ParserException)jjte000;
               }
               throw (Error)jjte000;
             } finally {
               if (jjtc000) {
                 jjtree.closeNodeScope(jjtn000, true);
               }
             }
/*@egen*/
	}


AbstractConstraint Constraint(ConstraintSystem constraintSystem):
{/*@bgen(jjtree) Constraint */
 SimpleNode jjtn000 = new SimpleNode(JJTCONSTRAINT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;
OWLObject owlObject;
Variable variable;
Set<OWLObject> owlObjects = new HashSet<OWLObject>();
Set<OWLEntity> matches = new HashSet<OWLEntity>();
InCollectionRegExpConstraint regexpConstraint;
}
{/*@bgen(jjtree) Constraint */
        try {
/*@egen*/
	t = <IDENTIFIER>
		{
			variable = constraintSystem.getVariable(t.image);
			if(variable==null){throw new ParseException("Undeclared variable "+t.image);}
		}
	(
	<MATCH><OPENPARENTHESYS>regexpConstraint = matchConstraint(variable, constraintSystem, stringOperation(constraintSystem, true))<CLOSEDPARENTHESYS>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{return regexpConstraint;}
	|	<NEQ> owlObject = OWLExpression(variable, constraintSystem)/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{return new InequalityConstraint(variable, owlObject,constraintSystem);}
	|	<IN><OPENCURLYBRACKETS>owlObject = OWLExpression(variable,constraintSystem)
		{owlObjects.add(owlObject);}
	(<COMMA> owlObject = OWLExpression(variable,constraintSystem)
		{owlObjects.add(owlObject);}
	)*
	<CLOSEDCURLYBRACKETS>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{return new InCollectionConstraint(variable,owlObjects, constraintSystem);}
	)/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

JAVACODE
InCollectionRegExpConstraint matchConstraint(Variable variable, ConstraintSystem cs, SingleValueGeneratedValue expression){/*@bgen(jjtree) matchConstraint */
SimpleNode jjtn000 = new SimpleNode(JJTMATCHCONSTRAINT);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
try {
/*@egen*/
int beginningSubSection = getToken(1).beginColumn;
int beginningSubSectionLine = getToken(1).beginLine;
//String expression = Utils.readString(this, true, QUOTE);
try {
	return  new InCollectionRegExpConstraint(variable, expression, cs);
} catch (PatternSyntaxException e) {
Exception temp=Utils.buildException(expression, beginningSubSection, beginningSubSectionLine, e);
throw new ParseException(temp.getMessage(), temp);
}/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

JAVACODE
OWLObject OWLExpression(Variable v, ConstraintSystem constraintSystem)
{/*@bgen(jjtree) OWLExpression */
             SimpleNode jjtn000 = new SimpleNode(JJTOWLEXPRESSION);
             boolean jjtc000 = true;
             jjtree.openNodeScope(jjtn000);
             try {
/*@egen*/
		Token t;
		String manSyntaxString="";
		while(true){
			t = getToken(1);
			if (t.kind==COMMA || t.kind ==CLOSEDCURLYBRACKETS || t.kind==SEMICOLON || t.kind==BEGIN || t.kind==END || t.kind == WHERE || t.kind == EOF){
				break;
			}else{
				manSyntaxString += t.image+" ";
				t = getNextToken();
			}
		}
	manSyntaxString = manSyntaxString.trim();
	ExpressionParser expressionParser = new ExpressionParser(manSyntaxString, constraintSystem);
	try{
	OWLObject toReturn = v.accept(expressionParser);
	return toReturn;
	} catch(Exception e){throw new ParseException(e.getMessage(), e);}/*@bgen(jjtree)*/
             } finally {
               if (jjtc000) {
                 jjtree.closeNodeScope(jjtn000, true);
               }
             }
/*@egen*/
}

VariableType variableType()      :{Token t;}
{
	t = <VARIABLETYPE>
		{return VariableType.valueOfIgnoreCase(t.image);}
}

OPPLQuery query(ConstraintSystem constraintSystem):{/*@bgen(jjtree) query */
        SimpleNode jjtn000 = new SimpleNode(JJTQUERY);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	OPPLQuery toReturn = getOPPLFactory().buildNewQuery(constraintSystem);
	AbstractConstraint c;}
{/*@bgen(jjtree) query */
        try {
/*@egen*/
	<SELECT>
		{completions.clear();}
	queryAtom(toReturn,constraintSystem)
	(<COMMA>
		{completions.clear();}
	queryAtom(toReturn,constraintSystem))*
	(<WHERE> c=Constraint(constraintSystem)
		{toReturn.addConstraint(c);}
	 (<COMMA> c=Constraint(constraintSystem)
	 	{toReturn.addConstraint(c);}
	 )*)?/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{return toReturn;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void queryAtom(OPPLQuery query, ConstraintSystem constraintSystem)      : {OWLAxiom axiom;}
{
	<ASSERTED> axiom = Clause(constraintSystem)
		{query.addAssertedAxiom(axiom);}
	| axiom = Clause(constraintSystem)
		{query.addAxiom(axiom);}
}

OWLAxiomChange Action(ConstraintSystem constraintSystem):{/*@bgen(jjtree) Action */
                                                          SimpleNode jjtn000 = new SimpleNode(JJTACTION);
                                                          boolean jjtc000 = true;
                                                          jjtree.openNodeScope(jjtn000);
/*@egen*/OWLAxiom axiom;}
{/*@bgen(jjtree) Action */
        try {
/*@egen*/
	<ADD> axiom = Clause(constraintSystem)/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{return new AddAxiom(constraintSystem.getOntology(), axiom);}
	|<REMOVE> axiom = Clause(constraintSystem)/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{return new RemoveAxiom(constraintSystem.getOntology(), axiom);}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

JAVACODE
OWLAxiom Clause(ConstraintSystem constraintSystem){/*@bgen(jjtree) Clause */
     SimpleNode jjtn000 = new SimpleNode(JJTCLAUSE);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);
     try {
/*@egen*/
	int beginningSubSection = -1;
	int beginningSubSectionLine = -1;
	OWLAxiom toReturn =null;
	String manSyntaxString="";
	Token t;
		while(true){
			t = getToken(1);
			if (beginningSubSection < 0) {beginningSubSection = t.beginColumn;}
			if (beginningSubSectionLine < 0) {beginningSubSectionLine = t.beginLine;}
			if (t.kind==COMMA || t.kind==SEMICOLON || t.kind==BEGIN || t.kind==END || t.kind == WHERE || t.kind == EOF){
				break;
			}else{
				manSyntaxString += t.image+" ";
				t = getNextToken();
			}
		}
	manSyntaxString = manSyntaxString.trim();
	VariableManchesterOWLSyntaxParser parser = new VariableManchesterOWLSyntaxParser(manSyntaxString, constraintSystem
					);
	//parser.setOWLEntityChecker(getOPPLFactory().getOWLEntityChecker());
	try{
		toReturn = parser.parseAxiom();

	}catch(ParserException e){
	Exception ex=Utils.buildException(beginningSubSection, beginningSubSectionLine, e);
	throw new ParseException("OPPLParser.Clause() \"" + manSyntaxString + "\"\t" + ex.getMessage(), ex);
	}
return toReturn;/*@bgen(jjtree)*/
     } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
     }
/*@egen*/
}

